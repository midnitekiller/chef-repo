#
# This file is auto-generated by Chef. 
# Local modifications will be overwritten.
#
# Copyright 2013, Peter Bengtson
#


# ---------------------------------------------------------------------
# PURGE and BAN will be allowed from these hosts.
# ---------------------------------------------------------------------

acl purge {
  "localhost";      # The Varnish server itself
<% for str in @allow_ban_subnets %>
<% ip, cidr = str.split "/" %>
  "<%= ip %>"/<%= cidr %>;
<% end %>
}


<% if @apps.any? { |k, v| v != [] } -%>
# ---------------------------------------------------------------------
# All services must have an /alive URL. This will be queried regularly
# and will control automatic failover of individual servers.
# ---------------------------------------------------------------------

probe alive {
  .url = "/alive";
  .interval = 15 s;
  .timeout = 14 s;
  .window = 8;
  .threshold = 3;
  .initial = 3;
  .expected_response = 200;
}


<% end -%>
<% if @riak_media_nodes.length > 0 -%>
# ---------------------------------------------------------------------
# For health checking and failover of Riak nodes.
# ---------------------------------------------------------------------

probe riak {
  .url = "/ping";
  .interval = 60 s;
  .timeout = 5 s;
  .window = 8;
  .threshold = 3;
  .initial = 3;
  .expected_response = 200;
}


<% end -%>


# ---------------------------------------------------------------------
# The default backend. 
# ---------------------------------------------------------------------

backend default {
      .host = "222.222.222.222";
      .port = "8888";
}


# ---------------------------------------------------------------------
# These are the API services to manage. 
# ---------------------------------------------------------------------

<% for app, nodes in @apps -%>
director <%= app['id'] %>_director round-robin {
<% for nd in nodes -%>
<% next unless nd['ipaddress'] -%>
  { .backend = { .host = "<%= nd['ipaddress'] %>"; .port = "80"; .probe = alive; }}
<% end -%>
}

<% end -%>

# ---------------------------------------------------------------------
# These are the Riak media servers to manage. 
# ---------------------------------------------------------------------

director media_riak_nodes_director round-robin {
<% for nd in @riak_media_nodes -%>  
<% next unless nd['ipaddress'] -%>
  { .backend = { .host = "<%= nd['ipaddress'] %>"; .port = "8098"; .probe = riak; }}
<% end -%>
}


# ---------------------------------------------------------------------
# This is where incoming requests are processed.
# ---------------------------------------------------------------------

sub vcl_recv {
  set req.backend = default;

  # Is this a ping to see if Varnish is up?
  if (req.request == "GET" && req.url == "/ping") {
      error 751 "Varnish ping";
  }

  if (req.url ~ "^/v[0-9]+/") {

      # This is an API request. Set header.
      call set_external_api_call_header;

      # Force JSON content type. It should be application/json anyway, but some
      # browsers don't give the client developer a choice.
      set req.http.Content-Type = "application/json";

      # API calls don't accept any cookies
      unset req.http.Cookie;

      # Compensate for the unfathomable suckiness of IE 8 and 9
      call handle_evil_empire_shitty_browsers;

  } else if (req.http.host ~ "^.*media\.") {

      # This is a request for static media
      call handle_media_request;

  } else {

      # This is a request to a client site (webshop_client, admin_client, etc)
      call massage_hostname;
  }
  call cors_preflight;
  call handle_purge;
  call handle_ban;
  call select_backend_director;
}


#
# Set the X-External-API-call header if the request originated from the web
#
sub set_external_api_call_header {
  # Set or remove the X-External-API-Call header depending on whether the
  # request arrived via SSL.
  if (true) {                                 # This is VERY temporary
    set req.http.X-External-API-Call = true;
  } else {
    unset req.http.X-External-API-Call;
  }
}


#
# Internet Exploder
#
sub handle_evil_empire_shitty_browsers {
  # Handle PUT and DELETE for IE 8 and 9
  if (req.http.User-Agent ~ "MSIE (8|9)" && req.request == "POST") {
    if (req.url ~ "\_method\=PUT") {
      set req.request = "PUT";
      set req.url = regsub(req.url, "\_method\=PUT", "");
    } else if (req.url ~ "\_method\=DELETE") {
      set req.request = "DELETE";
      set req.url = regsub(req.url, "\_method\=DELETE", "");
    }
    set req.http.Accept = "application/json";
  }

  # Transform _x-api-token to the standard X-API-Token header
  if (req.url ~ "\_x-api-token\=[^&]*") {
      set req.http.X-API-Token = regsub(req.url, "^.*(\_x-api-token\=)([^&]*).*$", "\2");
      set req.url = regsub(req.url, "\_x-api-token\=[^&]*", "");
  }
    
  # Transform _x-api-authenticate to the standard X-API-Authenticate header
  if (req.url ~ "\_x-api-authenticate\=[^&]*") {
      set req.http.X-API-Authenticate = regsub(req.url, "^.*(\_x-api-authenticate\=)([^&]*).*$", "\2");
      set req.url = regsub(req.url, "\_x-api-authenticate\=[^&]*", "");
  }
    
  # Remove query arg transformation artefacts
  set req.url = regsuball(req.url, "&+", "&");
  set req.url = regsub(req.url, "\?&+", "?");
  set req.url = regsub(req.url, "&$", "");
  set req.url = regsub(req.url, "\?$", "");
}


#
#
#
sub handle_media_request {
  # Load balancing and failover
  set req.backend = media_riak_nodes_director;
  # Restrict to GET
  if (req.request != "GET") {
    error 405 "Method not allowed";
  }
  # Remove the Referer HTTP header, since Riak 1.2 throws a 403 if it's present
  unset req.http.Referer;
}


#
# Handle CORS preflight
#
sub cors_preflight {
  if (req.request == "OPTIONS") {
      error 750 "CORS Preflight";
  } 
}


#
# Get the hostname in shape: remove leading www, etc.
#
sub massage_hostname {
  # Remove any leading "www." from the host
  set req.http.host = regsub(req.http.host, "(?i)^www\.", "");
}


#
# Implement the PURGE HTTP method
#
sub handle_purge {
  if (req.request == "PURGE") {
    if (!client.ip ~ purge) {
      error 405 "Not allowed.";
    }
    return(lookup);
  }
}


#
# Implement the BAN HTTP method
#
sub handle_ban {
  if (req.request == "BAN") {
    if (!client.ip ~ purge) {
      error 405 "Not allowed.";
    }
    set req.url = regsuball(req.url, "(?i)%5B", "[");
    set req.url = regsuball(req.url, "(?i)%5D", "]");
    set req.url = regsuball(req.url, "(?i)%5C", "\");
    set req.url = regsuball(req.url, "(?i)%7C", "|");
    set req.url = regsuball(req.url, "(?i)%3F", "?");
    ban("obj.http.X-URL ~ " + req.url);
    error 200 "Banned";
  }
}


#
# Select the appropriate backend director to use. This is the load
# balancing and failover management functionality in Varnish.
#

sub select_backend_director {
  if (req.url ~ "^/v[0-9]+/") {
      # This is a service call
<% for app, nd in @apps -%>
<% if app['service'] -%>
      if (req.url ~ "(?i)<%= app['path_regexp'] %>") {
          set req.backend = <%= app['id'] %>_director;
      }
<% end -%>
<% end -%>
  } else {
    # This is an ordinary HTML site
<% for app, nd in @apps -%>
<% unless app['service'] -%>
    if (req.http.host ~ "(?i)<%= app['host_regexp'] %>") {
      set req.backend = <%= app['id'] %>_director;
    }
<% end -%>
<% end -%>
  }}


# ---------------------------------------------------------------------
# This is where errors are processed. We use it to support CORS, by 
# means of a purely internal, temporary status code set by vlc_recv.
# We also support PURGE and BAN using custom error status codes.
# ---------------------------------------------------------------------

sub vcl_error {

    # This handles CORS preflight
    if (obj.status == 750) {
        set obj.status = 200;
        set obj.http.Access-Control-Allow-Origin = "*";
        set obj.http.Access-Control-Allow-Methods = "POST,GET,PUT,PATCH,DELETE,HEAD";
        set obj.http.Access-Control-Allow-Headers = "Content-Type,Accept,Origin,X-API-Authenticate,X-API-Token,Cache-Control";
        set obj.http.Access-Control-Max-Age = "3600";
        return (deliver);
    }

    # This handles /ping
    if (obj.status == 751) {
      set obj.status = 200;
      synthetic "OK";
      return(deliver);
    }

    # This handles PURGE
    if (req.request == "PURGE") {
      return(deliver);
    }

    # This handles BAN
    if (req.request == "BAN") {
      return(deliver);
    }

    # This handles 405 for media
    if (obj.status == 405) {
        return (deliver);
    }
}


# ---------------------------------------------------------------------
# We add the X-API-Token to the hash
# ---------------------------------------------------------------------

sub vcl_hash {
  hash_data(req.http.X-API-Token);
}


# ---------------------------------------------------------------------
# Processing of cache hits and misses, to implement PURGE.
# ---------------------------------------------------------------------

sub vcl_hit {
  if (req.request == "PURGE") {
    purge;
    error 200 "Purged";
  }
}

sub vcl_miss {
  if (req.request == "PURGE") {
    purge;
    error 404 "Not in cache";
  }
}

sub vcl_pass {
  if (req.request == "PURGE") {
    error 502 "PURGE on a passed object";
  }
}


# ---------------------------------------------------------------------
# This is where responses from the backend servers are processed
# before they are delivered and/or cached.
# ---------------------------------------------------------------------

sub vcl_fetch {
    # Remove fluff
    unset beresp.http.Server;
    unset beresp.http.X-Powered-By;
    unset beresp.http.X-Request-Id;
    # Expires is always removed (use Cache-Control instead)
    unset beresp.http.Expires;
<% if node.chef_environment == 'prod' -%>
    # Remove X-Runtime in production
    unset beresp.http.X-Runtime;                   # Might be useful in staging - but not in prod.
<% end -%>
    # Process API responses further
    if (req.url ~ "(?i)^/v[0-9]+/") {
        # This is a service call
        unset beresp.http.Set-Cookie;              # No cookies in service replies
        unset beresp.http.X-UA-Compatible;         # Remove HTML advisory header for IE
        # Prepare for smart BANs
        set beresp.http.X-Host = req.http.host;
        set beresp.http.X-Url = req.url;
   }
}


# ---------------------------------------------------------------------
# This is where outgoing responses to clients, from the cache or from
# the backend servers, are processed.
# ---------------------------------------------------------------------

sub vcl_deliver {
    # Remove fluff Varnish put there
    unset resp.http.X-Varnish;
    unset resp.http.Via;
<% if (node.chef_environment != 'prod' && node.chef_environment != 'staging') -%>
    # Extra debug headers
    #set resp.http.X-Backend-Debug = req.backend;
    #set resp.http.X-Provided-API-Authentication-Debug = req.http.X-API-Authenticate;
    #set resp.http.X-Provided-API-Token-Debug = req.http.X-API-Token;
    set resp.http.X-Varnish-Hits-Debug = obj.hits;
<% end -%>
    # If there is a s-maxage Cache-Control directive, remove it and set Age to 0.
    if (resp.http.Cache-Control ~ "s-maxage") {
      set resp.http.Cache-Control = regsub(resp.http.Cache-Control, "s-maxage\=[0-9]*", "");
      set resp.http.Age = 0;
    }
    # Remove BAN X-Host and X-Url
    unset resp.http.X-Host;
    unset resp.http.X-Url;
    # CORS stuff
    set resp.http.Access-Control-Allow-Origin = "*";
    set resp.http.Access-Control-Allow-Credentials = "true";
}
